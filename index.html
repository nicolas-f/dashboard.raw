<!DOCTYPE html>
<meta charset="utf-8">
<html>
  <head>
    <style>
      rect.bordered {
        /*stroke: #E6E6E6;
        stroke-width:2px;*/
      }

      text.mono {
        font-size: 9pt;
        font-family: Consolas, courier;
        fill: #aaa;
      }

      text.axis-workweek {
        fill: #000;
      }

      text.axis-worktime {
        fill: #000;
      }
    </style>
    <script src="https://d3js.org/d3.v5.min.js"></script>
  </head>
  <body>
  <div id="dataset-picker">
  </div>
    <div id="chart"></div>
    <script type="text/javascript">
      var margin = { top: 50, right: 0, bottom: 100, left: 80 },
          fields = [12500,10000,8000,6300,5000,4000,3150,2500,2000,1600,1250,1000,800,630,500,400,315,250,200,160,125,100,80,63,50,40,31,25,20];
          width = 960 - margin.left - margin.right,
          height = 500 - margin.top - margin.bottom,
          gridSize = Math.floor(width / 80),
          legendElementWidth = gridSize * 7,
          colors = ["#82A6AD","#A0BABF","#B8D6D1","#CEE4CC","#E2F2BF","#F3C683","#E87E4D","#CD463E","#A11A4D","#75085C","#430A4A"], // http://www.coloringnoise.com/theoretical_background/new-color-scheme/
          days = fields.map(f => f+" Hz"),
          datasets = [""];

      var svg = d3.select("#chart").append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
          .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      var dayLabels = svg.selectAll(".dayLabel")
          .data(days)
          .enter().append("text")
            .text(function (d) { return d; })
            .attr("x", 0)
            .attr("y", function (d, i) { return i * gridSize - 8; })
            .style("text-anchor", "end")
            .attr("transform", "translate(-6," + gridSize / 1.5 + ")")
            .attr("class", "dayLabel mono axis axis-workweek");

      var downloadedData = {};


      function onchange() {
        	selectValue = d3.select('#dataset-picker').property('value')
        	loadSensor(downloadedData, selectValue);
        };
      function loadSensor(jsonContent, sensorId) {

          var sensorId = jsonContent.aggregations.group.buckets[0].key;


          var select = d3.select('#dataset-picker')
            .append('select')
              .attr('class','select')
              .on('change',onchange)

          var options = select
            .selectAll('option')
            .data([sensorId]).enter()
            .append('option')
              .text(function (d) { return d; });


          var stepCount = jsonContent.aggregations.group.buckets[0].group_docs.hits.hits[0]._source.leq.length;
          var sensorData = jsonContent.aggregations.group.buckets[0].group_docs.hits.hits[0]._source;
          var sensorTime = jsonContent.aggregations.group.buckets[0].group_docs.hits.hits[0]._source.timestamp;
          var data = [];
          var t, freqIndex;
          for(t=0; t<stepCount; t++) {
            for(freqIndex=0; freqIndex < fields.length; freqIndex++) {
              freqField = fields[freqIndex];
              data.push({
                day: + (fields.length - (freqIndex+1)),
                hour: + (t+1),
                value: + sensorData['leq_'+freqField][t]
              });
            }
          }

          var colorScale = d3.scaleQuantize().domain([30,85]).range(colors);

          var cards = svg.selectAll(".hour")
              .data(data, function(d) {return d.day+':'+d.hour;});

          cards.append("title");

          var rect = cards.enter().append("rect");

          rect.attr("x", function(d) { return (d.hour - 1) * gridSize; })
              .attr("y", function(d) { return (d.day - 1) * gridSize; })
              .attr("class", "hour bordered")
              .attr("width", gridSize)
              .attr("height", gridSize)
              .style("fill", colors[0]).transition().duration(1000).style("fill", function(d) { return colorScale(d.value); })

          rect.append("title").text(function(d) { return new Date(sensorTime + (d.hour - 1) * 125).toISOString() + " : " + d.value; });

          var legend = svg.selectAll(".legend")
              .data(d3.range(colors.length));

          var legendgroup = legend.enter().append("g")
              .attr("class", "legend");

          legendgroup.append("rect")
            .attr("x", function(d, i) { return legendElementWidth * i; })
            .attr("y", height)
            .attr("width", legendElementWidth)
            .attr("height", legendElementWidth / 4)
            .style("fill", function(d, i) { return colors[i]; });

          legendgroup.append("text")
            .attr("class", "mono")
            .text(function(d) { var ranges = colorScale.invertExtent(colors[d]); return d == 0 ? "< " + Math.round(ranges[1]) : d < colors.length - 1 ? Math.round(ranges[0]) + " - " + Math.round(ranges[1]) : "> " + Math.round(ranges[0])})
            .attr("x", function(d, i) { return legendElementWidth * i + 15; })
            .attr("y", height + (legendElementWidth / 4) + 15);


        var timeLabels = svg.selectAll(".timeLabel")
            .data([0,1])
            .enter().append("text")
            .text(function(d) { return new Date(sensorTime + d * 125 * 80).toISOString(); })
            .attr("x", function(d, i) { return d == 0 ? 80 : i * gridSize * 79 - 80; })
            .attr("y", -8)
            .style("text-anchor", "middle")
            .attr("transform", "translate(" + gridSize / 2 + ", -6)")
            .attr("class", function(d, i) { return ((i >= 7 && i <= 16) ? "timeLabel mono axis axis-worktime" : "timeLabel mono axis"); });

      }

      var heatmapChart = function(sensorId) {
        d3.json("fast.json").then(function(jsonContent) {
          downloadedData = jsonContent;
          loadSensor(jsonContent, sensorId);
        });
      };

      heatmapChart("");

    </script>
  </body>
</html>
